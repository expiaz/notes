When the CPU runs in its intial 16-bit real mode, the maximum size of the registers is 16 bits, which means that the highest address we can reference in an instruction is 0xffff, which amounts by today’s standards to a measily 64 KB (65536 bytes). Now, perhaps the likes of our intended simple operating system would not be affected by this limit,but a day-to-day operating systems would never sit comfortably in such a tight box, so it is important that we understand the solution, of segmentation, to this problem.
To get around this limitation, the CPU designers added a few more special registers, cs, ds, ss, and es, called segment registers. We can imagine main memory as being divided into segments that are indexed by the segment registers, such that, when we specify a 16-bit address, the CPU automatically calculates the absolute address as the appropriate segment’s start address offseted by our specified address. By appropriate segment, I mean that, unless explicitly told otherwise, the CPU will offset our address from the segment register appropriate for the context of our instruction, for example: the address used in the instruction mov ax, [0x45ef] would by default be offset from the data segment, indexed by ds; similarly, the stack segment, ss, is used to modify the actual location of the stack’s base pointer, bp.
The most confusing thing about segment addressing is that adjacent segments overlap almost completely but for 16 bytes, so different segment and offset combinations can actually point to the same physical address; but enough of the talk: we won’t truly grasp this concept until we’ve seen some examples.
To calculate the absolute address the CPU multiplies the value in the segment register by 16 and then adds your offset address; and because we are working with hexadecimal, when we multiple a number by 16, we simply shift it a digit to the left (e.g. 0x42 * 16 = 0x420).
So if we set ds to 0x4d and then issue the statement mov ax, [0x20], the value stored in ax will actually be loaded from address 0x4d0 (16 * 0x4d + 0x20).

The maximum addresses possibles are 2^20 because we shift 4 bits to the left during the address translation